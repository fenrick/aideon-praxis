#!/usr/bin/env node
import { access, mkdir, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

async function fileExists(filePath) {
  try {
    await access(filePath);
    return true;
  } catch (error) {
    if (error && (error.code === 'ENOENT' || error.code === 'ENOTDIR')) {
      return false;
    }
    throw error;
  }
}

function createBanner(message) {
  return `// ${message}\n// Generated by scripts/inject-version.mjs\n`;
}

async function writeTypeScriptVersion(targetPath, version) {
  const banner = createBanner('This file is auto-generated. Do not edit manually.');
  const contents = `${banner}export const version = '${version}';\n`;
  await mkdir(path.dirname(targetPath), { recursive: true });
  await writeFile(targetPath, contents, 'utf8');
  return targetPath;
}

async function writePythonVersion(targetPath, version) {
  const header = '# This file is auto-generated by scripts/inject-version.mjs.\n';
  const contents = `${header}__version__ = "${version}"\n`;
  await mkdir(path.dirname(targetPath), { recursive: true });
  await writeFile(targetPath, contents, 'utf8');
  return targetPath;
}

async function updateJsonVersion(targetPath, version, updater) {
  const raw = await readFile(targetPath, 'utf8');
  const data = JSON.parse(raw);
  updater(data, version);
  const contents = `${JSON.stringify(data, null, 2)}\n`;
  await writeFile(targetPath, contents, 'utf8');
  return targetPath;
}

async function main() {
  const [, , version] = process.argv;

  if (!version) {
    console.error('Usage: node scripts/inject-version.mjs <version>');
    process.exit(1);
  }

  const updatedFiles = [];

  // Desktop renderer version file
  updatedFiles.push(
    await writeTypeScriptVersion(
      path.join(repoRoot, 'app/desktop/src/version.ts'),
      version
    )
  );

  // Optional worker version file(s)
  const workerTargets = [
    path.join(repoRoot, 'app/worker/python/src/aideon_worker/_version.py')
  ];

  for (const workerPath of workerTargets) {
    if (await fileExists(workerPath)) {
      updatedFiles.push(await writePythonVersion(workerPath, version));
    }
  }

  // Update Tauri configuration so bundles use the semantic-release version
  const tauriConfigPath = path.join(repoRoot, 'crates/tauri/tauri.conf.json');
  if (await fileExists(tauriConfigPath)) {
    updatedFiles.push(
      await updateJsonVersion(tauriConfigPath, version, (data, newVersion) => {
        data.version = newVersion;
      })
    );
  }

  console.log('Updated version in:');
  for (const file of updatedFiles) {
    console.log(` - ${path.relative(repoRoot, file)}`);
  }
}

main().catch((error) => {
  console.error('Failed to inject version:', error);
  process.exit(1);
});
