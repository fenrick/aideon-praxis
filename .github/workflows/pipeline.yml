name: Pipeline

on:
  push:
  pull_request:
  schedule:
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      runSonar:
        description: 'Run SonarCloud analysis'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '24'
  PYTHON_VERSION: '3.13'
  PNPM_VERSION: '9.12.0'

permissions:
  contents: read

concurrency:
  group: pipeline-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  rust_checks:
    name: Rust Checks
    runs-on: ubuntu-latest
    # Minimal Rust gating (fmt/clippy) for crates/tauri only; no Tauri build yet.
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install Linux GUI deps (wry/gtk/glib)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pkg-config libglib2.0-dev libgtk-3-dev libayatana-appindicator3-dev \
            librsvg2-dev libwebkit2gtk-4.1-dev libsoup-3.0-dev

      - name: Install Rust (stable, fmt+clippy)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy, llvm-tools-preview

      - name: Cache Cargo & Target
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            crates/tauri/target
          key: ${{ runner.os }}-rust-${{ hashFiles('crates/tauri/Cargo.toml') }}
          restore-keys: |
            ${{ runner.os }}-rust-

      - name: Generate lockfile (for audit & caching)
        working-directory: crates/tauri
        run: cargo generate-lockfile

      - name: Create Linux placeholder sidecar (externalBin)
        if: runner.os == 'Linux'
        run: |
          set -euo pipefail
          mkdir -p crates/tauri/binaries
          touch crates/tauri/binaries/aideon-worker-x86_64-unknown-linux-gnu
          chmod +x crates/tauri/binaries/aideon-worker-x86_64-unknown-linux-gnu

      - name: Cargo fmt (check)
        working-directory: crates/tauri
        run: cargo fmt --all --check

      - name: Cargo clippy (deny warnings)
        working-directory: crates/tauri
        run: cargo clippy --all-targets -- -D warnings

      - name: Cargo check (typecheck)
        working-directory: crates/tauri
        run: cargo check --all-targets --all-features

      - name: Cargo test
        working-directory: crates/tauri
        run: cargo test --all --quiet

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-llvm-cov

      - name: Rust coverage (LCOV)
        working-directory: crates/tauri
        run: |
          mkdir -p coverage
          cargo llvm-cov --lcov --output-path coverage/lcov.info --all-targets

      - name: Clippy JSON report (for Sonar import)
        working-directory: crates/tauri
        run: |
          # Generate Clippy JSON without -D warnings (warnings already denied above)
          cargo clippy --message-format=json -q > coverage/clippy.json || true

      - name: Upload Rust coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-rs
          if-no-files-found: warn
          retention-days: 7
          path: |
            crates/tauri/coverage

      - name: Cache RustSec advisory DB
        uses: actions/cache@v4
        with:
          path: ~/.cargo/advisory-db
          key: ${{ runner.os }}-rust-advisorydb
          restore-keys: |
            ${{ runner.os }}-rust-advisorydb

      - name: Install cargo-audit (prebuilt)
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-audit

      - name: Cargo audit (advisories)
        working-directory: crates/tauri
        run: |
          # Do not fail the pipeline on third-party advisory noise yet; surface as warnings
          cargo audit -D warnings || echo "[warn] cargo-audit failed; see advisories"

  js_checks:
    name: JS/TS Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm ${{ env.PNPM_VERSION }}
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Get pnpm store directory
        id: pnpm-store
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.STORE_PATH }}
          key: ${{ runner.os }}-node-${{ env.NODE_VERSION }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.NODE_VERSION }}-pnpm-

      - name: Install JS dependencies
        run: pnpm install --frozen-lockfile

      - name: JS Format Check
        run: pnpm run node:format:check

      - name: JS Lint
        run: pnpm run node:lint

      - name: JS Typecheck
        run: pnpm run node:typecheck

      - name: JS Tests + Coverage
        run: pnpm run node:test:coverage

      - name: Upload TS coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-ts
          if-no-files-found: warn
          retention-days: 7
          path: |
            coverage/lcov.info

  py_checks:
    name: Python Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm ${{ env.PNPM_VERSION }}
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Get pnpm store directory
        id: pnpm-store-py
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store-py.outputs.STORE_PATH }}
          key: ${{ runner.os }}-node-${{ env.NODE_VERSION }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.NODE_VERSION }}-pnpm-

      - name: Install JS dependencies (for pnpm run state)
        run: pnpm install --frozen-lockfile

      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          version: latest

      - name: Cache uv and virtualenvs
        uses: actions/cache@v4
        with:
          path: |
            .venv
            packages/worker/.venv
            ~/.cache/uv
          key: ${{ runner.os }}-node-${{ env.NODE_VERSION }}-uv-${{ env.PYTHON_VERSION }}-${{ hashFiles('uv.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.NODE_VERSION }}-uv-${{ env.PYTHON_VERSION }}-

      - name: Python Sync (uv) â€” worker venv
        run: pnpm run worker:sync

      - name: Python Lint (ruff+black --check)
        run: pnpm run worker:lint

      - name: Python Typecheck (mypy)
        run: pnpm run worker:typecheck

      - name: Python Typecheck (pyright)
        run: pnpm run worker:pyright

      - name: Python Security (bandit)
        run: pnpm run worker:sec

      - name: Python Dead code (vulture)
        run: pnpm run worker:deadcode

      - name: Python Tests + Coverage (pytest-cov)
        run: pnpm run worker:test:cov

      - name: Worker UDS Smoke (ping + state_at)
        shell: bash
        run: |
          set -euo pipefail
          rm -f .aideon/worker.sock || true
          # Start worker in background
          (AIDEON_WORKER_LOG=INFO pnpm run worker:serve >/tmp/worker.log 2>&1 &)
          # Wait for readiness
          for i in {1..100}; do
            if curl --unix-socket .aideon/worker.sock -sS http://localhost/ping | grep -q '"pong"'; then
              break
            fi
            sleep 0.1
          done
          echo "Ping OK"
          # Verify state_at endpoint
          curl --unix-socket .aideon/worker.sock -sS -H 'content-type: application/json' \
            -d '{"asOf":"2025-01-01"}' http://localhost/state_at | tee /tmp/state_at.json
          jq -e '.asOf=="2025-01-01" and .nodes==0 and .edges==0' /tmp/state_at.json >/dev/null
          echo "state_at OK"

      - name: Upload Python coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-py
          if-no-files-found: warn
          retention-days: 7
          path: packages/worker/coverage.xml

  sonar:
    name: SonarCloud
    runs-on: ubuntu-latest
    needs: [js_checks, py_checks, rust_checks]
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main' || github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.runSonar == true)
    permissions:
      contents: read
      pull-requests: read
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download TS coverage
        uses: actions/download-artifact@v5
        with:
          name: coverage-ts
          path: coverage

      - name: Download Python coverage
        uses: actions/download-artifact@v5
        with:
          name: coverage-py
          path: packages/worker

      - name: Download Rust coverage
        uses: actions/download-artifact@v5
        with:
          name: coverage-rs
          path: crates/tauri/coverage

      - name: Normalize coverage paths
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p coverage packages/worker crates/tauri/coverage
          # TS coverage (downloaded directly to coverage/)
          if [[ -f coverage/lcov.info ]]; then
            echo "TS coverage at coverage/lcov.info"
          elif [[ -f coverage-ts/lcov.info ]]; then
            mv coverage-ts/lcov.info coverage/lcov.info
          elif [[ -f coverage-ts/coverage/lcov.info ]]; then
            mv coverage-ts/coverage/lcov.info coverage/lcov.info
          elif [[ -f lcov.info ]]; then
            mv lcov.info coverage/lcov.info
          else
            echo "[warn] TS coverage lcov.info not found after artifact download" >&2
          fi

          # Normalize/Filter TS LCOV: keep only project sources and repo-relative paths
          if [[ -f coverage/lcov.info ]]; then
            awk '
              function normalize(p) {
                gsub(/\\r$/, "", p);
                # strip runner absolute prefix -> repo root
                sub(/\/home\/runner\/work\/[^/]+\/[^/]+\//, "", p);
                sub(/^\/github\/workspace\//, "", p);
                return p;
              }
              /^SF:/ {
                path=$0; sub(/^SF:/, "", path);
                npath=normalize(path);
                keep=(npath ~ /^(app\/desktop\/src|packages\/adapters\/src)\/.*\.(ts|tsx|js|jsx)$/);
                if (keep) {
                  print "SF:" npath;
                  in_file=1;
                } else {
                  in_file=0;
                }
                next;
              }
              { if (in_file==1) print $0 }
            ' coverage/lcov.info > coverage/lcov.filtered && mv coverage/lcov.filtered coverage/lcov.info
          fi

          # Python coverage (downloaded directly to packages/worker/)
          if [[ -f packages/worker/coverage.xml ]]; then
            echo "Py coverage at packages/worker/coverage.xml"
          elif [[ -f coverage-py/coverage.xml ]]; then
            mv coverage-py/coverage.xml packages/worker/coverage.xml
          elif [[ -f coverage.xml ]]; then
            mv coverage.xml packages/worker/coverage.xml
          elif [[ -f coverage-py/packages/worker/coverage.xml ]]; then
            mv coverage-py/packages/worker/coverage.xml packages/worker/coverage.xml
          else
            echo "[warn] Python coverage coverage.xml not found after artifact download" >&2
          fi
          # Rewrite Cobertura <source> to container mount so Sonar resolves paths cleanly
          if [[ -f packages/worker/coverage.xml ]]; then
            sed -i -E 's#<source>.*packages/worker/src</source>#<source>/github/workspace/packages/worker/src</source>#' packages/worker/coverage.xml || true
          fi

          # Rust coverage (LCOV -> Generic Coverage XML)
          # Locate the LCOV file from the artifact
          if [[ -f crates/tauri/coverage/lcov.info ]]; then
            echo "Rust lcov at crates/tauri/coverage/lcov.info"
          elif [[ -f coverage-rs/lcov.info ]]; then
            mv coverage-rs/lcov.info crates/tauri/coverage/lcov.info
          elif [[ -f coverage-rs/crates/tauri/coverage/lcov.info ]]; then
            mv coverage-rs/crates/tauri/coverage/lcov.info crates/tauri/coverage/lcov.info
          else
            echo "[warn] Rust coverage lcov.info not found after artifact download" >&2
          fi

          # Normalize Rust LCOV paths to repo-relative to help Sonar resolve files
          if [[ -f crates/tauri/coverage/lcov.info ]]; then
            sed -E 's#^(SF:)/home/runner/work/[^/]+/[^/]+/#+\1#; s#^(SF:)/github/workspace/#+\1#' \
              crates/tauri/coverage/lcov.info > crates/tauri/coverage/lcov.norm && \
              mv crates/tauri/coverage/lcov.norm crates/tauri/coverage/lcov.info
          fi

          # No Rust XML conversion required; Sonar ingests LCOV directly via sonar.rust.lcov.reportPaths
          ls -l coverage || true
          ls -l packages/worker || true
          ls -l crates/tauri/coverage || true

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
